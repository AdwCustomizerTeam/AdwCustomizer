#!/usr/bin/env python3

# cli.py
#
# Change the look of Adwaita, with ease
# Copyright (C) 2022 Gradience Team
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import os
import sys
import json
import shutil
import signal
import argparse
import warnings

version = "@VERSION@"
is_local = @local_build@

if is_local:
    # In the local use case, use gradience module from the sourcetree
    sys.path.insert(1, '@PYTHON@')

    # In the local use case the installed schemas go in <builddir>/data
    os.environ["XDG_DATA_DIRS"] = '@SCHEMAS_DIR@:' + os.environ.get("XDG_DATA_DIRS", "")

signal.signal(signal.SIGINT, signal.SIG_DFL)

warnings.filterwarnings("ignore") # suppress GTK warnings

from gi.repository import GLib, Gio, Xdp

from gradience.backend.utils.common import to_slug_case
from gradience.backend.globals import preset_repos, presets_dir

from gradience.backend.theming.monet import Monet
from gradience.backend.models.preset import Preset
from gradience.backend.theming.preset_utils import PresetUtils
from gradience.backend.preset_downloader import PresetDownloader
from gradience.backend.flatpak_overrides import create_gtk_user_override, remove_gtk_user_override

from gradience.backend.logger import Logger

logging = Logger()


class CLI:
    settings = Gio.Settings.new("@APP_ID@")
    portal = Xdp.Portal()

    def __init__(self):
        self.parser = argparse.ArgumentParser(description="Gradience - Change the look of Adwaita, with ease")
        self.parser.add_argument("-V", "--version", action="version", version=f"Gradience, version {version}")
        #self.parser.add_argument("-j", "--json", action="store_true", help="print out a result of the command directly in JSON format")
        #self.parser.add_argument('-J', '--pretty-json', dest='pretty_json', action='store_true', help='pretty-print JSON output')

        subparsers = self.parser.add_subparsers(dest="command")

        #info_parser = subparsers.add_parser("info", help="show information about Gradience")

        presets_parser = subparsers.add_parser("presets", help="list installed presets")
        #presets_parser.add_argument("-r", "--remove-preset", metavar="PRESET_NAME", help="remove a preset from the list")
        presets_parser.add_argument("-j", "--json", action="store_true", help="print out a result of this command directly in JSON format")

        favorites_parser = subparsers.add_parser("favorites", help="list favorite presets")
        favorites_parser.add_argument("-a", "--add-preset", metavar="PRESET_NAME", help="add a preset to favorites")
        favorites_parser.add_argument("-r", "--remove-preset", metavar="PRESET_NAME", help="remove a preset from favorites")
        favorites_parser.add_argument("-j", "--json", action="store_true", help="print out a result of this command directly in JSON format")

        import_parser = subparsers.add_parser("import", help="import a preset")
        import_parser.add_argument("-p", "--preset-path", help="absolute path to a preset file", required=True)

        apply_parser = subparsers.add_parser("apply", help="apply a preset")
        apply_group = apply_parser.add_mutually_exclusive_group(required=True)
        apply_group.add_argument("-n", "--preset-name", help="display name for a preset")
        apply_group.add_argument("-p", "--preset-path", help="absolute path to a preset file")
        apply_parser.add_argument("--gtk", choices=["gtk4", "gtk3", "both"], default="gtk4", help="types of applications you want to theme (default: gtk4)")
        #apply_parser.add_argument("--flatpak", choices=["gtk4", "gtk3", "both"], help="types of Flatpak applications you want to theme (for GTK3 option, make sure you have adw-gtk3 installed as Flatpak)")

        #new_parser = subparsers.add_parser("new", help="create a new preset")
        #new_parser.add_argument("-i", "--interactive", action="store_true", help="")
        #new_parser.add_argument("-n", "--name", help="display name for a preset", required=True)
        #new_parser.add_argument("--colors", help="", required=True)
        #new_parser.add_argument("--palette", help="")
        #new_parser.add_argument("--custom-css", help="")
        #new_parser.add_argument("-j", "--json", action="store_true", help="print out a result of this command directly in JSON format")

        download_parser = subparsers.add_parser("download", help="download preset from a preset repository")
        #new_parser.add_argument("-i", "--interactive", action="store_true", help="")
        download_parser.add_argument("-n", "--preset-name", help="name of a preset you want to get", required=True)
        #download_parser.add_argument("--custom-url", help="use custom repository's presets.json to download other presets")

        monet_parser = subparsers.add_parser("monet", help="generate Material You preset from an image")
        monet_parser.add_argument("-n", "--preset-name", help="name for a generated preset", required=True)
        monet_parser.add_argument("-p", "--image-path", help="abosulte path to image", required=True)
        monet_parser.add_argument("--tone", default=20, help="a tone for colors (default: 20)")
        monet_parser.add_argument("--theme", choices=["light", "dark"], default="light", help="choose whatever it should be a light or dark theme (default: light)")
        monet_parser.add_argument("-j", "--json", action="store_true", help="print out a result of this command directly in JSON format")

        overrides_parser = subparsers.add_parser("flatpak-overrides", help="enable or disable Flatpak theming")
        overrides_group = overrides_parser.add_mutually_exclusive_group(required=True)
        overrides_group.add_argument("-e", "--enable-theming", choices=["gtk4", "gtk3", "both"], help="enable overrides for Flatpak theming")
        overrides_group.add_argument("-d", "--disable-theming", choices=["gtk4", "gtk3", "both"], help="disable overrides for Flatpak theming")

        self.__parse_args()

    def __print_json(self, data, pretty=False):
        if pretty:
            print(json.dumps(data, indent=4))
        else:
            print(json.dumps(data))

    def __parse_args(self):
        args = self.parser.parse_args()

        if not args.command:
            print(self.parser.format_help())

        if args.command == "presets":
            self.list_presets(args)

        elif args.command == "favorites":
            self.favorite_presets(args)

        elif args.command == "import":
            self.import_preset(args)

        elif args.command == "apply":
            self.apply_preset(args)

        elif args.command == "new":
            self.new_preset(args)

        elif args.command == "download":
            self.download_preset(args)

        elif args.command == "monet":
            self.generate_monet(args)

        elif args.command == "flatpak-overrides":
            self.flatpak_theming(args)

    def list_presets(self, args):
        #_remove_preset = args.remove_preset
        _json = args.json

        if _json:
            presets_list = PresetUtils().get_presets_list(json_output=True)
            print(presets_list)
            exit(0)

        presets_list = PresetUtils().get_presets_list()

        # TODO: Modify this output to look more like a table (maybe use ncurses?)
        print("\033[1;37mPreset name\033[0m | \033[1;37mPreset path\033[0m")
        for key in presets_list:
            print(f"{presets_list[key]} -> {key}")

    def favorite_presets(self, args):
        _add_preset = args.add_preset
        _remove_preset = args.remove_preset
        _json = args.json

        favorite = set(self.settings.get_value("favourite"))
        presets_list = PresetUtils().get_presets_list()
        presets_name = list(presets_list.values())

        if _json and not _add_preset and not _remove_preset:
            favorites_json = {"favorites": list(favorite), "amount": len(favorite)}
            json_output = json.dumps(favorites_json)
            print(json_output)
            exit(0)
        elif _json and _add_preset or _json and _remove_preset:
            logging.error("JSON output option isn't available for --add-preset and --remove-preset options.")
            exit(1)

        if _add_preset:
            if _add_preset in presets_name:
                favorite.add(_add_preset)
                self.settings.set_value("favourite", GLib.Variant("as", favorite))
                logging.info(f"Preset {_add_preset} has been added to favorites.")
                exit(0)
            else:
                logging.error(f"Preset named {_add_preset} isn't installed in Gradience. "
                    "Check if you typed the correct preset name, or try importing your preset using 'import' command.")
                exit(1)

        if _remove_preset:
            if _remove_preset in favorite:
                favorite.remove(_remove_preset)
                self.settings.set_value("favourite", GLib.Variant("as", favorite))
                logging.info(f"Preset {_add_preset} has been removed from favorites.")
                exit(0)
            else:
                logging.error(f"Preset named {_remove_preset} doesn't exist in favorites list. "
                    "Check if you typed the correct preset name.")
                exit(1)

        logging.info("Favorite presets list:")
        for i, preset in enumerate(favorite):
            print(preset)

        logging.info(f"Favorites amount: {len(favorite)}")
        exit(0)

    def import_preset(self, args):
        _preset_path = args.preset_path

        preset_file = GLib.path_get_basename(_preset_path)
        logging.info(f"Importing preset: {preset_file.strip()}")

        # TODO: Check if preset is already imported
        if _preset_path.endswith(".json"):
            shutil.copy(
                _preset_path,
                os.path.join(
                    presets_dir,
                    "user",
                    preset_file.strip()
                )
            )
            logging.info("Preset imported successfully.")
        else:
            logging.error("Unsupported file format, must be .json")
            exit(1)

    def apply_preset(self, args):
        _preset_name = args.preset_name
        _preset_path = args.preset_path
        _gtk = args.gtk
        #_flatpak = args.flatpak

        presets_list = PresetUtils().get_presets_list()
        presets_name = list(presets_list.values())

        if _preset_name:
            if _preset_name in presets_name:
                for path, name in presets_list.items():
                    if name == _preset_name:
                        preset = Preset().new_from_path(path)
        elif _preset_path:
            preset = Preset().new_from_path(_preset_path)

        if _gtk == "gtk4":
            PresetUtils().apply_preset("gtk4", preset)
            logging.info(f"Preset {preset.display_name} applied successfully for Gtk 4 applications.")
        elif _gtk == "gtk3":
            PresetUtils().apply_preset("gtk3", preset)
            logging.info(f"Preset {preset.display_name} applied successfully for Gtk 3 applications.")
        logging.info("In order for changes to take full effect, you need to log out.")

    def new_preset(self, args):
        #_interactive = args.interactive
        _name = args.name
        _colors = args.colors
        _palette = args.palette
        _custom_css = args.custom_css
        _json = args.json

        # TODO: Do the logic code for `new` command

        logging.error("This command isn't implemented yet")
        exit(1)

    def download_preset(self, args):
        #_interactive = args.interactive
        _preset_name = args.preset_name
        #_custom_url = args.custom_url

        for repo_name, repo in preset_repos.items():
            try:
                explore_presets, urls = PresetDownloader().fetch_presets(repo)
            except (GLib.GError, json.JSONDecodeError) as e:
                logging.error(f"An error occurred while fetching presets from remote repository. Exc: {e}")
                exit(1)
            else:
                for (preset, preset_name), preset_url in zip(explore_presets.items(), urls):
                    # TODO: Add handling of two or more presets with the same elements in name
                    if _preset_name.lower() in preset_name.lower():
                        logging.info(f"Downloading preset: {preset_name}")
                        try:
                            PresetDownloader().download_preset(preset_name, to_slug_case(repo_name), preset_url)
                        except (GLib.GError, json.JSONDecodeError, OSError) as e:
                            logging.error(f"An error occurred while downloading a preset. Exc: {e}")
                            exit(1)
                        else:
                            logging.info("Preset downloaded successfully.")
                    else:
                        logging.error(f"No presets found with text: {_preset_name}")
                        exit(1)

    # TODO: Fix support for Flatpak builds \
    # Current issue: Monet class can't generate Monet palette from image located in host, because it doesn't have any permissions to read user directories. \
    # It is recommended to use portals instead of just allowing Gradience to read all user files. For this purpose, we can should be able to use one of the available portals. \
    # Possible useful portals: org.freedesktop.portal.Documents (support missing in libportal, only D-Bus calls), org.freedesktop.portal.FileChooser
    def generate_monet(self, args):
        _preset_name = args.preset_name
        _image_path = args.image_path
        _tone = args.tone
        _theme = args.theme
        _json = args.json

        is_sandboxed = self.portal.running_under_sandbox()
        if is_sandboxed:
            logging.error("Preset generation in 'monet' command isn't yet available for Flatpak installations.")
            exit(1)

        palette = Monet().generate_from_image(_image_path)
        props = [_tone, _theme]

        if _json:
            preset = PresetUtils().new_preset_from_monet(name=_preset_name, monet_palette=palette,
                                                            props=props, obj_only=True)
            preset_json = preset.get_preset_json()
            print(preset_json)
            exit(0)

        PresetUtils().new_preset_from_monet(_preset_name, palette, props)
        logging.info("In order for changes to take full effect, you need to log out.")

    def flatpak_theming(self, args):
        _enable_theming = args.enable_theming
        _disable_theming = args.disable_theming

        if _enable_theming == "gtk4":
            create_gtk_user_override(self.settings, "gtk4")
            logging.info("Flatpak theming for Gtk 4 applications has been enabled.")
        elif _enable_theming == "gtk3":
            create_gtk_user_override(self.settings, "gtk3")
            logging.info("Flatpak theming for Gtk 3 applications has been enabled.")
        elif _enable_theming == "both":
            create_gtk_user_override(self.settings, "gtk4")
            create_gtk_user_override(self.settings, "gtk3")
            logging.info("Flatpak theming for Gtk 4 and Gtk 3 applications has been enabled.")

        if _disable_theming == "gtk4":
            remove_gtk_user_override(self.settings, "gtk4")
            logging.info("Flatpak theming for Gtk 4 applications has been disabled.")
        elif _disable_theming == "gtk3":
            remove_gtk_user_override(self.settings, "gtk3")
            logging.info("Flatpak theming for Gtk 3 applications has been disabled.")
        elif _disable_theming == "both":
            remove_gtk_user_override(self.settings, "gtk4")
            remove_gtk_user_override(self.settings, "gtk3")
            logging.info("Flatpak theming for Gtk 4 and Gtk 3 applications has been disabled.")


if __name__ == "__main__":
    cli = CLI()
